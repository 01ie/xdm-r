Bug修复方案
1. 修复 XDMUtils.decodeFileName 函数
位置：app/src/main/java/xdman/util/XDMUtils.java:53-72

修改内容：

public static String decodeFileName(String str) {
    try {
        // 使用标准URL解码器，支持正确的UTF-8处理
        return java.net.URLDecoder.decode(str, "UTF-8");
    } catch (Exception e) {
        // 降级到原有逻辑，保持兼容性
        char ch[] = str.toCharArray();
        StringBuffer buf = new StringBuffer();
        for (int i = 0; i < ch.length; i++) {
            if (ch[i] == '/' || ch[i] == '\\' || ch[i] == '"' || ch[i] == '?'
                    || ch[i] == '*' || ch[i] == '<' || ch[i] == '>'
                    || ch[i] == ':')
                continue;
            if (ch[i] == '%') {
                if (i + 2 < ch.length) {
                    int c = Integer.parseInt(ch[i + 1] + "" + ch[i + 2], 16);
                    buf.append((char) c);
                    i += 2;
                    continue;
                }
            }
            buf.append(ch[i]);
        }
        return buf.toString();
    }
}

修改原因：

优先使用标准URL解码器处理正确的UTF-8编码
保留原有逻辑作为fallback，确保向后兼容
2. 修复 NetUtils.getNameFromContentDisposition 函数
位置：app/src/main/java/xdman/util/NetUtils.java:120-149

修改内容：
在现有的getExtendedContentDisposition函数中加强filename*参数的处理：

private static String getExtendedContentDisposition(String header) {
    try {
        String arr[] = header.split(";");
        for (String str : arr) {
            if (str.contains("filename*")) {
                int index = str.lastIndexOf("'");
                if (index > 0) {
                    String st = str.substring(index + 1);
                    return XDMUtils.decodeFileName(st); // 确保使用改进的解码
                }
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}

修改原因：

确保filename*参数使用改进的解码函数
保持现有逻辑不变，只修复解码部分
修复原理
主要问题：decodeFileName函数无法正确处理UTF-8百分号编码
解决方案：优先使用Java标准URL解码器，它能正确处理UTF-8字符
向后兼容：保留原有逻辑作为fallback，确保不破坏现有功能
最小修改：只修改必要的函数，不添加额外代码